<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-item/paper-item-body.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../bower_components/app-storage/app-localstorage/app-localstorage-document.html">
<link rel="import" href="../bower_components/app-storage/app-indexeddb-mirror/app-indexeddb-mirror.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="shared-styles.html">
<link rel="import" href="preferences.html">
<script src="../bower_components/moment/min/moment.min.js"></script>
<script src="../browserify-libs.js"></script>

<dom-module id="x-balances">
  <template>
    <style include="shared-styles iron-flex iron-flex-alignment">
      .container {
        display: flex;
        padding: 10px 10px 20px 10px;
      }
      paper-button {
        font-family: 'Roboto', 'Noto', sans-serif;
        font-weight: normal;
        font-size: 14px;
        -webkit-font-smoothing: antialiased;
      }
      paper-button.primary {
        background-color: var(--app-primary-color);
        color: white;
        --paper-button-raised-keyboard-focus: {
          background-color: var(--paper-pink-a200) !important;
          color: white !important;
        };
      }
      paper-button.primary:hover {
        background-color: var(--paper-indigo-400);
      }
      paper-input {
        margin-right: 0.29em;
      }
      .red {
        color: var(--paper-red-600);
      }
      div.list paper-item {
        border-bottom: 1px solid var(--paper-grey-600);
      }
      div.list paper-item:first-child {
        border-top: 1px solid var(--paper-grey-600);
      }
      span.info {
        font-size: 12px;
        color: var(--paper-item-body-secondary-color, var(--secondary-text-color));
        margin-left: 2px;
      }
    </style>

    <div class="container layout horizontal">
      <paper-input
        class="flex"
        value="{{addressInput}}"
        label="Enter a Bitcoin address"
        auto-validate="false"
        error-message="{{inputErrorMessage}}"
        invalid="{{inputInvalid}}">
      </paper-input>
      <paper-button raised class="primary self-center" on-click="addAddress">add</paper-button>
    </div>
    <template is="dom-if" if="{{storedAddresses.length}}">
      <span class="info">Updated [[_getLastBalanceResponseTime(lastBalanceResponse)]]</span>
    </template>
    <div class="list">
      <template is="dom-repeat" items="{{storedAddresses}}">
        <paper-item>
          <paper-item-body two-line>
            <div>[[item.address]]</div>
            <div secondary>[[_getBalance(item.address, lastBalanceResponse, btcFormat)]]</div>
          </paper-item-body>
          <paper-icon-button icon="delete" class="red" on-click="deleteAddress"></paper-button>
        </paper-item>
      </template>
    </div>

    <iron-ajax
      id="balanceRequest"
      url="/api/balance"
      params="[[_getBalanceRequestParams(storedAddresses.splices)]]">
    </iron-ajax>
    <app-localstorage-document id="lastBalanceResponse" key="LastBalanceResponse" data="{{lastBalanceResponse}}">
    <app-localstorage-document id="addresses" key="Addresses" data="{{storedAddresses}}">
    <app-localstorage-document key="SavedBtcFormat" data="{{btcFormat}}">
  </template>

  <script>
    class Balances extends Polymer.Element {
      static get is() { return 'x-balances' }

      static get properties() {
        return {
          addressInput: {
            type: String,
          },
          storedAddresses: {
            type: Array,
            value: () => [],
          },
          lastBalanceResponse: {
            type: Object,
            value: () => ({}),
          },
          inputInvalid: {
            type: Boolean,
            value: false,
          },
          inputErrorMessage: {
            type: String,
          },
        }
      }

      ready() {
        super.ready()
        this.$.lastBalanceResponse.transactionsComplete.then(() => {
          this.$.addresses.transactionsComplete.then(() => {
            this.updateBalances({force: false})
          })
        })
      }

      addAddress() {
        if (this.addressExists(this.addressInput)) {
          this.inputErrorMessage = 'The address is already saved'
          this.inputInvalid = true
        } else if (!bitcoin.isValidBitcoinAddress(this.addressInput)) {
          this.inputErrorMessage = 'Not a valid address'
          this.inputInvalid = true
        } else {
          this.push('storedAddresses', {address: this.addressInput})
          this.updateBalances({force: true})
          this.addressInput = ''
        }
      }

      addressExists(a) {
        return this.storedAddresses.find(({address}) => address === a)
      }

      deleteAddress(e) {
        this.splice('storedAddresses', e.model.get('itemsIndex'), 1)
      }

      updateBalances({force = false}) {
        if (this.storedAddresses.length === 0) {
          return
        }

        const withinTimeLimit = () => this.lastBalanceResponse.time
          ? moment(this.lastBalanceResponse.time).add(1, 'minute').isAfter(moment(), 'minute')
          : true

        if (force || !withinTimeLimit()) {
          const request = this.$.balanceRequest.generateRequest()
          request.completes.then((e) => {
            this.lastBalanceResponse = {
              time: new Date(),
              data: e.parseResponse(),
            }
          })
        }
      }

      _getLastBalanceResponseTime(lastBalanceResponse) {
        if (!lastBalanceResponse.time) {
          return '-'
        }
        const updatedAt = moment(lastBalanceResponse.time)
        if (updatedAt.isSame(moment(), 'day')) {
          return updatedAt.format('HH:mm')
        } else {
          return updatedAt.format('YYYY-MM-DD HH:mm')
        }
      }

      _getBalanceRequestParams(changeRecord) {
        const active = this.storedAddresses
          .map(({address}) => address)
          .join('|')
        return {active}
      }

      _getBalance(address, lastBalanceResponse, btcFormat) {
        const amount = lastBalanceResponse.data
          && lastBalanceResponse.data[address]
          && btcFormat
          ? lastBalanceResponse.data[address].final_balance / btcFormat.divideBy
          : '-'
        return amount + ' ' + (btcFormat ? btcFormat.name : 'BTC')
      }
    }

window.customElements.define(Balances.is, Balances)
  </script>
</dom-module>
